#version 450
#extension GL_GOOGLE_include_directive : require

#include "common.h"

layout(local_size_x = COMPUTE_GROUP_SIZE_X) in;

struct IndirectCmdData {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(push_constant) uniform params_t {
    mat4 mProjView;
} params;

layout(std430, binding = 0) readonly buffer BoxData {
    box4 instanceBboxes[];
};

layout(std430, binding = 1) buffer InstanceIndices {
    uint markedInstanceIndices[];
};

layout(std430, binding = 2) buffer IndirectCommand {
    IndirectCmdData cmd;
};

bool pointIsInFrustrum(vec4 p)
{
    return p.x >= -1.0 && p.x <= 1.0 &&
           p.y >= -1.0 && p.y <= 1.0 &&
           p.z >= 0.0 && p.z <= 1.0;
}

vec4 worldToClip(vec4 v)
{
    vec4 hom = params.mProjView * v;
    return hom / hom.w;
}

void main() 
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx < instanceBboxes.length()) {
        box4 bbox = instanceBboxes[idx];

        vec3 bMin = bbox.min.xyz;
        vec3 bMax = bbox.max.xyz;

        // @TODO: optimize this
        vec4 p1 = worldToClip(bbox.min);
        vec4 p2 = worldToClip(vec4(bbox.min.x, bbox.min.y, bbox.max.z, 1.0));
        vec4 p3 = worldToClip(vec4(bbox.min.x, bbox.max.y, bbox.min.z, 1.0));
        vec4 p4 = worldToClip(vec4(bbox.max.x, bbox.min.y, bbox.min.z, 1.0));
        vec4 p5 = worldToClip(vec4(bbox.max.x, bbox.min.y, bbox.max.z, 1.0));
        vec4 p6 = worldToClip(vec4(bbox.min.x, bbox.max.y, bbox.max.z, 1.0));
        vec4 p7 = worldToClip(vec4(bbox.max.x, bbox.max.y, bbox.min.z, 1.0));
        vec4 p8 = worldToClip(bbox.max);

        if (pointIsInFrustrum(p1) ||
            pointIsInFrustrum(p2) ||
            pointIsInFrustrum(p3) ||
            pointIsInFrustrum(p4) ||
            pointIsInFrustrum(p5) ||
            pointIsInFrustrum(p6) ||
            pointIsInFrustrum(p7) ||
            pointIsInFrustrum(p8))
        {
            markedInstanceIndices[atomicAdd(cmd.instanceCount, 1)] = idx;
        }
    }
}
