#version 450
#extension GL_ARB_shader_image_load_store : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "common.h"

#define TEX_REGION_DIM (WORK_GROUP_DIM + 2*GAUSS_WINDOW_HALFSIZE)

layout(local_size_x = WORK_GROUP_DIM, local_size_y = WORK_GROUP_DIM) in;

layout(binding = 0, rgba8) uniform image2D framebuffer;

layout(binding = 1) uniform GaussParams
{
    shader_float gauss_coeffs[GAUSS_WINDOW_SIZE];
};

shared vec3 texture_region_cache[TEX_REGION_DIM][TEX_REGION_DIM];

void cache_image_piece(ivec2 imSize, ivec2 localCoord, ivec2 globalCoord)
{
    const float sectorSize = float(TEX_REGION_DIM) / float(WORK_GROUP_DIM);
    const int sectorSizeI = int(ceil(sectorSize));

    ivec2 texCoord = localCoord * sectorSizeI;
    ivec2 regionCoordBase = globalCoord - localCoord - ivec2(GAUSS_WINDOW_HALFSIZE);

    ivec2 texCoordMin = ivec2(regionCoordBase.x + texCoord.x >= 0 ? texCoord.x : -regionCoordBase.x,
                              regionCoordBase.y + texCoord.y >= 0 ? texCoord.y : -regionCoordBase.y);
    ivec2 texCoordMax = ivec2(regionCoordBase.x + texCoord.x + sectorSizeI < imSize.x ? texCoord.x + sectorSizeI : imSize.x - regionCoordBase.x,
                              regionCoordBase.y + texCoord.y + sectorSizeI < imSize.y ? texCoord.y + sectorSizeI : imSize.y - regionCoordBase.y);

    for (int y = texCoordMin.y; y < min(TEX_REGION_DIM, texCoordMax.y); y++)
        for (int x = texCoordMin.x; x < min(TEX_REGION_DIM, texCoordMax.x); x++) {
            ivec2 regionCoord = regionCoordBase + ivec2(x, y);
            texture_region_cache[y][x] = imageLoad(framebuffer, regionCoord).xyz;
        }
}

void main() 
{
    ivec2 imSize = imageSize(framebuffer);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    ivec2 globalCoord = ivec2(gl_GlobalInvocationID.xy);

    if (globalCoord.x >= imSize.x || globalCoord.y >= imSize.y)
        return;

    cache_image_piece(imSize, localCoord, globalCoord);
    barrier();

    int x = max(0, globalCoord.x - GAUSS_WINDOW_HALFSIZE);
    int coeffId = x - (globalCoord.x - GAUSS_WINDOW_HALFSIZE);
    int cacheX = localCoord.x + coeffId;
    vec3 col = vec3(0.0);
    float coeffSum = 0.0;
    while (x < min(imSize.x, globalCoord.x + GAUSS_WINDOW_HALFSIZE + 1)) {
        col += gauss_coeffs[coeffId] * texture_region_cache[localCoord.y + GAUSS_WINDOW_HALFSIZE][cacheX];
        coeffSum += gauss_coeffs[coeffId];
        x++;
        cacheX++;
        coeffId++;
    }

    imageStore(framebuffer, globalCoord, vec4(col/coeffSum, 1.0));

    barrier();

    cache_image_piece(imSize, localCoord, globalCoord);
    barrier();

    int y = max(0, globalCoord.y - GAUSS_WINDOW_HALFSIZE);
    coeffId = y - (globalCoord.y - GAUSS_WINDOW_HALFSIZE);
    int cacheY = localCoord.y + coeffId;
    col = vec3(0.0);
    coeffSum = 0.0;
    while (y < min(imSize.y, globalCoord.y + GAUSS_WINDOW_HALFSIZE + 1)) {
        col += gauss_coeffs[coeffId] * texture_region_cache[cacheY][localCoord.x + GAUSS_WINDOW_HALFSIZE];
        coeffSum += gauss_coeffs[coeffId];
        y++;
        cacheY++;
        coeffId++;
    }

    imageStore(framebuffer, globalCoord, vec4(col/coeffSum, 1.0));
}
