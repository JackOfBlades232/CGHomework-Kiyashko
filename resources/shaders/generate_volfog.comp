#version 450
#extension GL_ARB_shader_image_load_store : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "common.h"

#include "noise.glsl.inc"

layout(local_size_x = VOLFOG_WORK_GROUP_DIM, local_size_y = VOLFOG_WORK_GROUP_DIM) in;

layout(push_constant) uniform params_t
{
  mat4 mInvProjView;
} params;

layout(binding = 0, set = 0) uniform AppData
{
  UniformParams uParams;
};

layout(binding = 1, r32f) uniform image2D fogMap;
layout(binding = 2)       uniform sampler2D depthTex;

const float raymarching_step    = 0.2;
const int raymarching_max_steps = 30;

void main()
{
  const ivec2 imgSize = imageSize(fogMap);
  const ivec2 globalCoord = ivec2(gl_GlobalInvocationID.xy);
  const vec2 texCoord = gl_GlobalInvocationID.xy / vec2(imgSize);

  if (globalCoord.x < imgSize.x && globalCoord.y < imgSize.y)
  {
    const float depth = textureLod(depthTex, texCoord, 0).x;
    const vec4 initPosHom = params.mInvProjView * vec4((2.0*texCoord)-1.0, 0.0, 1.0);
    const vec4 finalPosHom = params.mInvProjView * vec4((2.0*texCoord)-1.0, depth, 1.0);

    const vec4 initPos = initPosHom / initPosHom.w;
    const vec4 finalPos = finalPosHom / finalPosHom.w;

    vec3 pos = initPos.xyz;
    const vec3 dir = normalize(finalPos - initPos).xyz;
    float intensity = 0.0;
    for (int i = 0;
         i <= min(floor(length(finalPos - initPos) / raymarching_step), raymarching_max_steps-1);
         ++i)
    {
      const float distance = i * raymarching_step;

      // Regular fog
      const float noise = simplex3d_fractal(pos - uParams.windVel * uParams.time);
      intensity += (noise + 1.0) * 0.5 * 0.05;

      // @TODO(PKiyashko): sdf clouds some day
      // @TODO(PKiyashko): blue noise to remove raymarching artifacts
      // @TODO(PKiyashko): volumetric rays w/ sampling shadow map

      pos += dir * raymarching_step;
    }

    imageStore(fogMap, globalCoord, vec4(clamp(intensity, 0.0f, 1.0f), 1.0f, 1.0f, 1.0f));
  }
}
