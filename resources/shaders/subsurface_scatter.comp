#version 450
#extension GL_GOOGLE_include_directive : require

#include "common.h"

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform params_t
{
  SSS_PARAMS_FIELDS
} params;

// @NOTE: this should have an indicator use/don't use SSS in alpha channel,
//        but in this here HW we use it for all objects => we do not do this
//        This also does not use specular component, which would have to be
//        rendered separately
layout(binding = 0, rgba8) uniform image2D colorMap;
layout(binding = 1) uniform sampler2D depthMap;

const vec4 kernel[] = 
{
    vec4(0.530605, 0.613514, 0.739601, 0),
    vec4(0.000973794, 1.11862e-005, 9.43437e-007, -3),
    vec4(0.00333804, 7.85443e-005, 1.2945e-005, -2.52083),
    vec4(0.00500364, 0.00020094, 5.28848e-005, -2.08333),
    vec4(0.00700976, 0.00049366, 0.000151938, -1.6875),
    vec4(0.0094389, 0.00139119, 0.000416598, -1.33333),
    vec4(0.0128496, 0.00356329, 0.00132016, -1.02083),
    vec4(0.017924, 0.00711691, 0.00347194, -0.75),
    vec4(0.0263642, 0.0119715, 0.00684598, -0.520833),
    vec4(0.0410172, 0.0199899, 0.0118481, -0.333333),
    vec4(0.0493588, 0.0367726, 0.0219485, -0.1875),
    vec4(0.0402784, 0.0657244, 0.04631, -0.0833333),
    vec4(0.0211412, 0.0459286, 0.0378196, -0.0208333),
    vec4(0.0211412, 0.0459286, 0.0378196, 0.0208333),
    vec4(0.0402784, 0.0657244, 0.04631, 0.0833333),
    vec4(0.0493588, 0.0367726, 0.0219485, 0.1875),
    vec4(0.0410172, 0.0199899, 0.0118481, 0.333333),
    vec4(0.0263642, 0.0119715, 0.00684598, 0.520833),
    vec4(0.017924, 0.00711691, 0.00347194, 0.75),
    vec4(0.0128496, 0.00356329, 0.00132016, 1.02083),
    vec4(0.0094389, 0.00139119, 0.000416598, 1.33333),
    vec4(0.00700976, 0.00049366, 0.000151938, 1.6875),
    vec4(0.00500364, 0.00020094, 5.28848e-005, 2.08333),
    vec4(0.00333804, 7.85443e-005, 1.2945e-005, 2.52083),
    vec4(0.000973794, 1.11862e-005, 9.43437e-007, 3),
};

float sampleLinearDepth(vec2 tc)
{
  float depth = texture(depthMap, tc).x;
  return params.zNear * params.zFar / (depth * (params.zFar - params.zNear) - params.zFar);
}

void main()
{
  ivec2 texSize = imageSize(colorMap);
  if (gl_GlobalInvocationID.x >= texSize.x || gl_GlobalInvocationID.y >= texSize.y)
    return;

  vec2 texCoord = gl_GlobalInvocationID.xy / vec2(texSize);

  vec4 color = imageLoad(colorMap, ivec2(gl_GlobalInvocationID.xy));
  float depth = sampleLinearDepth(texCoord);

  //vec2 stepDir = params.isHorizontal ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec2 stepDir = params.isHorizontal > 0.5 ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  float distanceToScreen = 1.0 / tan(0.5 * radians(params.cameraFov));
  vec2 blurStep = (0.333 * stepDir * params.blurScale * distanceToScreen) / depth;

  vec3 blurredRgb = color.xyz * kernel[0].xyz;
  for (int i = 1; i < kernel.length(); ++i)
  {
    vec2 sampleTexCoord = texCoord + blurStep * kernel[i].a;
    if (sampleTexCoord.x < 0.0 || sampleTexCoord.y < 0.0 ||
        sampleTexCoord.x > 1.0 || sampleTexCoord.y > 1.0)
    {
      blurredRgb += color.xyz * kernel[i].xyz;
      continue;
    }

    ivec2 sampleCoord = ivec2(sampleTexCoord * texSize);
    vec4 sampleColor = imageLoad(colorMap, sampleCoord);
    float sampleDepth = sampleLinearDepth(sampleTexCoord);

    float coeff = clamp(
        abs(sampleDepth - depth) * params.blurScale * distanceToScreen * params.depthAwareCorrection,
        0.0, 1.0);
    blurredRgb += mix(sampleColor, color, coeff).xyz * kernel[i].xyz;
  }
  
  imageStore(colorMap, ivec2(gl_GlobalInvocationID.xy), vec4(blurredRgb, 1.0));
}
